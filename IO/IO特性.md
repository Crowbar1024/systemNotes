### 缓冲IO
Linux的标准函数库中，有一种被称作缓冲I/O的操作，其特征就是对应每一个打开的文件，在内存中都有一片缓冲区。

每次读文件时，会连续的读出若干条记录，这样在下次读文件时就可以直接从内存的缓冲区读取；同样，每次写文件的时候也仅仅是写入内存的缓冲区，等满足了一定的条件（如缓存写满了，或遇到换行符，或用户强制fflush），再将缓冲区中的内容一次性写入文件。
BUFSIZ为系统默认的缓冲区大小。我在ubuntu测是是8192，2^13


这种技术大大增加了文件读写的速度，但也给编程代来了一点儿麻烦：
* 比如有一些数据，认为已经写入了文件，实际上因为没有满足特定的条件，它们还只是保存在缓冲区内。————这时用_exit()函数直接将进程关闭，缓冲区的数据就会丢失。因此，要想保证数据的完整性，就一定要使用exit()函数。

关于行缓存，全缓存，无缓存
https://blog.csdn.net/puddinghamster/article/details/51841786
在redis的学习中，提到随机数据要取决于数组的大小，如果大小刚刚符合了缓存行的64字节的话就不怎么消耗性能（除了第一次，以后的访问直接命中）



### 默认打开
在 Linux 系统中，对于每个进程来说，始终有 3 个"文件"处于打开状态：stdin、stdout、stderr。每个打开的文件都会被分配一个文件描述符。stdin，stdout 和 stderr 的文件描述符分别是 0，1 和 2。
对于 Bash 进程（一种主流的shell）来说，stdin 默认输入就是键盘，stdout 和 stderr 默认输出都是屏幕。

需要注意的是，这三者等类型为 FILE*，是文件流，可以这样得到对应的文件流使用的fd：
```c++
printf("%d \n",fileno(stdin));
```
STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO 等类型为 int。就是前者的对应fd值。




